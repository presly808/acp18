1. bankExample:
    В примере имитируется банк со многими счетами.
    В программе случайным образом формируются транзакции, переводящие деньги с одного счета на другой.
    Каждый счет владеет одним потоком.
    Каждая транзакция перемещает произвольную сумму денег с одного счета на другой произвольно выбираемый счет.
    Общая сумму денег банка по всем счетам должна оставаться неизменной, поскольку деньги переводятся со счета на счет,
    а не снимаются окончательно.
    Чтобы прекратить выполнение программы необходимо нажать комбинацию клавиш <Ctrl + F2>.
    При выполнении общий баланс в течение нескольких транзакций в имитируемом банке остается равным 100000$,
    но через некоторое время общий баланс изменяется.
    Задание:
    1) Необходимо исправить поведение программы, общий баланс не должен изменяться.
    2) Необходимо добавить новый функционал. Сейчас можно снять деньги со счета, если на остатке есть достаточно средств.
       Если на остатке нет средств, транзакция должна перейти в режим ожидания, пока возможно другая транзакция не пополнит
       данный счет на недостающую сумму.
    3) Пример взаимной блокировки:
           Счет 1: сумма $200
           Счет 2: сумма $300
           Поток 1: переводит сумму $300 со счета 1 на счет 2
           Поток 2: переводит сумму $400 со счета 2 на счет 1
           Потоки 1 и 2 блокируются. Ни один из них не выполнится, поскольку остатков на счетах недостаточно для выполнения транзакции

       Вопрос: почему в bankExample после реализации п.1 взаимная блокировка не может произойти?

       Необходимо изменить bankExample, чтобы произошла ситуация взаимных блокировок.
       Варианты:
       a) исключите лимит $1000 на транзакцию. Установите значение константы NACCOUNTS равным 10 (чтобы ускорить наступление
          вз. блокировки), сконструируйте объект типа Runnable со значением поля max,
          равным 2*INITIAL_BALANCE, и запустите программу на выполнение.
       b) сделайте i-й поток ответственным за размещение денег на i-м счете вместо их снятия с i-го счета.
          В этом случае имеется вероятность, что все потоки набросятся на один и тот же счет и каждый из них будет пытаться
          снять с него деньги.
       с) SignalAll() заменить на Signal()
          Пример, когда такая замена сработает:
             Счет 1: сумма $1990
             Все прочие счета: сумма $990 на каждом
             Поток 1: переводит сумму $995 со счета 1 на счет 2
             Все прочие потоки: переводят сумму $995 со своего счета на другой
             Все потоки кроме 1 заблокированы, поскольку на их счетах недостаточно денег.
             Поток 1 выполняет перевод денег:
             Счет 1: сумма $995
             Счет 2: сумма $1985
             Все прочие счета: сумма $990 на каждом
             В потоке 1 вызывается метод signal()/notify(), который произвольным образом выбирает поток для разблокировки
             Допустим, он выбирает поток 3. Этот поток активизируется, средств недостаточно, вызывается  await()/wait().
             Поток 1 продолжает работать, но если сумма перевода больше чем остаток, метод await()/wait() вызывается и для потока 1.
             В итоге все потоки заблокированы.
       d) Ваш вариант
       Когда программа зависнет, для завершения работы нажмите комбинацию клавиш <Ctrl + Break>. С помощью этой комбинации можно
       посмотреть сожержание памяти с вычислением всех потоков.

    4) Задание 1) предусматривает добавление блокировок. Необходимо оптимизировать работу программы. Разделите блокировки на
       readLock() и writeLock()
       Теория:
       Lock readLock() - получает блокировку чтения, которая может быть захвачена многими читающими потоками, но
       исключая все записывающие потоки.
       Lock writeLock() - получает блокировку записи, исключающую доступ для всех читающих и остальных записывающих потоков.

2.* matchCounting:
    В примере пользователь вводит каталог, программа подсчитывает количество файлов каталога, содержащих ключевое слово.
    Поиск выполняется в одном потоке.

    1) Необходимо распараллелить процесс.
        Теория:
        - интерфейс Runnable инкапсулирует задачу, выполняющуюся асинхронно.
        - интерфейс Callable подобен интерфейсу Runnable, но в нем предусмотрен возврат значения.
        - сохранение результатов асинхронного вычисления обеспечивает интрефейс Future. Владелец объекта типа Future может
        получить результат, когда он будет готов.
        - класс FutureTask реализует интерфейсы Future и Runnable, конструктор FutureTask принимает Callable.

    2) Если в программе создается большое количество кратковременных потоков, то имеет смысл использовать пул потоков.
        В пуле потоков содержится целый ряд простаивающих потоков, готовых к запуску.
        Также пул позволяет ограничить количество параллельно выполняющихся потоков.
        Необходимо распараллелить процесс, используя пул потоков.
        Теория:
        - ExecutorService newCachedThreadPool()  - возвращает пул, создающий потоки по мере необходимости и закрывающий потоки,
        которые простаивают более 60 секунд.
        - ExecutorService newFixedThreadPool()  - возвращает пул, использующий заданное количество потоков для запуска задач.
        - Future <T> submit (Callable/Runnable task) - передает указанную задачу на выполнение
        - void shutdown() - останавливает службу, завершая все запущенные задачи и не принимая новых.

3.* forkJoin:
    Имеется задача обработки, естественно разделяемая на подзадачи следующим образом:
    if (problemSize < threshold)
      решить задачу непосредственно
    else
      разделить задачу на подзадачи, решить каждую подзадачу рекурсивно и объединить полученные результаты

    Пример такой задачи - обработка изображений
    Пример учебный - ForkJoinTest - считает количество элементов в массиве с определенным свойством.
    Подсчет выполняется в одном потоке.
    Необходимо распараллелить процесс с использованием архитектуры вилочного соединения.
    Теория:
     - Необходимо создать класс, расширяющий класс RecursiveTask<T> (T - это тип результата вычисления) и переопределить
     метод compute() для формирования и вызова подзадач, а также объединения результатов их выполнения.
     - Метод invokeAll() получает ряд задач и блоков до тех пор, пока их выполнение не будет завершено. Вызывает метод compute()
     для переданных задач.
     - Метод join() объединяет полученные результаты. Метод вызывается для каждой подзадачи, в итоге возвращает сумму результатов
    их выполнения.










